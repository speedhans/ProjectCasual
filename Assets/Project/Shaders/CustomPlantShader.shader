Shader "Custom/CustomPlantShader"
{
	Properties
	{
		[NoScaleOffset] _MainTexture("MainTexture", 2D) = "white" {}
[NoScaleOffset] _AlphaTexture("AlphaTexture", 2D) = "white" {}
_AlphaClipping("AlphaClipping ", Range(0, 1)) = 0.5
_Specular("Specular", Color) = (0,0,0,0)
_WindPower("WindPower ", Float) = 0
_WindDirection("WindDirection", Vector) = (0,0,0,0)

	}
		SubShader
{
	Tags
	{
		"RenderPipeline" = "LightweightPipeline"
		"RenderType" = "Opaque"
		"Queue" = "Geometry+0"
	}
	Pass
	{
		Tags{"LightMode" = "LightweightForward"}

		// Material options generated by graph

		Blend One Zero, One Zero

		Cull Back

		ZTest LEqual

		ZWrite On

		HLSLPROGRAM
	// Required to compile gles 2.0 with standard srp library
	#pragma prefer_hlslcc gles
	#pragma exclude_renderers d3d11_9x
	#pragma target 2.0

	// -------------------------------------
	// Lightweight Pipeline keywords
	#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
	#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
	#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
	#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
	#pragma multi_compile _ _SHADOWS_SOFT
	#pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE

	// -------------------------------------
	// Unity defined keywords
	#pragma multi_compile _ DIRLIGHTMAP_COMBINED
	#pragma multi_compile _ LIGHTMAP_ON
	#pragma multi_compile_fog

	//--------------------------------------
	// GPU Instancing
	#pragma multi_compile_instancing

	#pragma vertex vert
	#pragma fragment frag

	// Defines generated by graph
	#define _SPECULAR_SETUP 1
	#define _AlphaClip 1

	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

	CBUFFER_START(UnityPerMaterial)
	float _AlphaClipping;
	float4 _Specular;
	float _WindPower;
	float3 _WindDirection;
	CBUFFER_END

	TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
	TEXTURE2D(_AlphaTexture); SAMPLER(sampler_AlphaTexture); float4 _AlphaTexture_TexelSize;
	SAMPLER(_SampleTexture2DLOD_BBB0CEFD_Sampler_3_Linear_Repeat);
	SAMPLER(_SampleTexture2D_1A51F6F2_Sampler_3_Linear_Repeat);
	struct VertexDescriptionInputs
	{
		float3 WorldSpacePosition;
		half4 uv0;
		float3 TimeParameters;
	};

	struct SurfaceDescriptionInputs
	{
		float3 TangentSpaceNormal;
		half4 uv0;
	};


	void Unity_Multiply_float(float A, float B, out float Out)
	{
		Out = A * B;
	}

	void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
	{
		Out = UV * Tiling + Offset;
	}


float2 Unity_GradientNoise_Dir_float(float2 p)
{
	// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
	p = p % 289;
	float x = (34 * p.x + 1) * p.x % 289 + p.y;
	x = (34 * x + 1) * x % 289;
	x = frac(x / 41) * 2 - 1;
	return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

	void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
	{
		float2 p = UV * Scale;
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(Unity_GradientNoise_Dir_float(ip), fp);
		float d01 = dot(Unity_GradientNoise_Dir_float(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		Out = lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x) + 0.5;
	}

	void Unity_Subtract_float(float A, float B, out float Out)
	{
		Out = A - B;
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
	{
		RGBA = float4(R, G, B, A);
		RGB = float3(R, G, B);
		RG = float2(R, G);
	}

	void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
	{
		Out = A * B;
	}

	void Unity_Add_float3(float3 A, float3 B, out float3 Out)
	{
		Out = A + B;
	}

	void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
	{
		Out = lerp(A, B, T);
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		float multi1 = IN.TimeParameters.x * _WindPower;

		float2 tiling1 = IN.WorldSpacePosition.xy * float2(1, 1) + multi1.xx;
		float gradientnoise1;
		Unity_GradientNoise_float(tiling1, 2, gradientnoise1);

		float sub1 = gradientnoise1 - 0.5;;
		float multi2 = sub1 * 0.3;
		float _Split_DE0131F3_R_1 = IN.WorldSpacePosition[0];
		float _Split_DE0131F3_G_2 = IN.WorldSpacePosition[1];
		float _Split_DE0131F3_B_3 = IN.WorldSpacePosition[2];
		float _Split_DE0131F3_A_4 = 0;

		float add1 = multi2 + _Split_DE0131F3_R_1;
		float4 _Combine_F661715B_RGBA_4;
		float3 _Combine_F661715B_RGB_5;
		float2 _Combine_F661715B_RG_6;
		Unity_Combine_float(add1, _Split_DE0131F3_G_2, _Split_DE0131F3_B_3, 0, _Combine_F661715B_RGBA_4, _Combine_F661715B_RGB_5, _Combine_F661715B_RG_6);

		float3 _Property_B33F094A_Out_0 = _WindDirection;
		float _Property_DBEE1A40_Out_0 = _WindPower;
		float3 multi3 = _WindDirection * (_WindPower.xxx);
		float _Vector1_6FC841E9_Out_0 = 0.2;
		float3 multi4 = multi3 * (_Vector1_6FC841E9_Out_0.xxx);
		float3 add2 = (_Combine_F661715B_RGBA_4.xyz) + multi4;

		float4 alphasample = SAMPLE_TEXTURE2D_LOD(_AlphaTexture, sampler_AlphaTexture, IN.uv0.xy, 0);
		description.Position = lerp(IN.WorldSpacePosition, add2, (alphasample.y));
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Normal;
		float3 Emission;
		float3 Specular;
		float Smoothness;
		float Occlusion;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float4 _SampleTexture2D_1A51F6F2_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, IN.uv0.xy);
		float _SampleTexture2D_1A51F6F2_R_4 = _SampleTexture2D_1A51F6F2_RGBA_0.r;
		float _SampleTexture2D_1A51F6F2_G_5 = _SampleTexture2D_1A51F6F2_RGBA_0.g;
		float _SampleTexture2D_1A51F6F2_B_6 = _SampleTexture2D_1A51F6F2_RGBA_0.b;
		float _SampleTexture2D_1A51F6F2_A_7 = _SampleTexture2D_1A51F6F2_RGBA_0.a;
		float4 _Property_91DFE63F_Out_0 = _Specular;
		float _Property_77F583FF_Out_0 = _AlphaClipping;
		surface.Albedo = (_SampleTexture2D_1A51F6F2_RGBA_0.xyz);
		surface.Normal = IN.TangentSpaceNormal;
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Specular = (_Property_91DFE63F_Out_0.xyz);
		surface.Smoothness = 0.5;
		surface.Occlusion = 1;
		surface.Alpha = _SampleTexture2D_1A51F6F2_A_7;
		surface.AlphaClipThreshold = _Property_77F583FF_Out_0;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct GraphVertexOutput
	{
		float4 clipPos                : SV_POSITION;
		DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
		half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
		float4 shadowCoord            : TEXCOORD2;

		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		half4 uv0 : TEXCOORD8;
		half4 uv1 : TEXCOORD9;

		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	};

	GraphVertexOutput vert(GraphVertexInput v)
	{
		GraphVertexOutput o = (GraphVertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;

		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

		// Vertex description inputs defined by graph
		vdi.WorldSpacePosition = WorldSpacePosition;
		vdi.uv0 = uv0;
		vdi.TimeParameters = _TimeParameters.xyz;

		VertexDescription vd = PopulateVertexData(vdi);
		v.vertex.xyz = vd.Position;

		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.uv0 = uv0;
		o.uv1 = uv1;

		float3 lwWNormal = TransformObjectToWorldNormal(v.normal);

		VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);

		// We either sample GI from lightmap or SH.
		// Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
		// see DECLARE_LIGHTMAP_OR_SH macro.
		// The following funcions initialize the correct variable with correct data
		OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
		OUTPUT_SH(lwWNormal, o.vertexSH);

		half3 vertexLight = VertexLighting(vertexInput.positionWS, lwWNormal);
		half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
		o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
		o.clipPos = vertexInput.positionCS;

	#ifdef _MAIN_LIGHT_SHADOWS
		o.shadowCoord = GetShadowCoord(vertexInput);
	#endif
		return o;
	}

	half4 frag(GraphVertexOutput IN) : SV_Target
	{
		UNITY_SETUP_INSTANCE_ID(IN);
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

		// Pixel transformations performed by graph
		float3 WorldSpacePosition = IN.WorldSpacePosition;
		float3 WorldSpaceNormal = IN.WorldSpaceNormal;
		float3 WorldSpaceTangent = IN.WorldSpaceTangent;
		float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
		float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
		float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
		float4 uv0 = IN.uv0;
		float4 uv1 = IN.uv1;
		float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

		SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
		surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
		surfaceInput.uv0 = uv0;

		SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

		float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Specular = float3(0, 0, 0);
		float Metallic = 1;
		float3 Normal = float3(0, 0, 1);
		float3 Emission = 0;
		float Smoothness = 0.5;
		float Occlusion = 1;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
		Albedo = surf.Albedo;
		Normal = surf.Normal;
		Emission = surf.Emission;
		Specular = surf.Specular;
		Smoothness = surf.Smoothness;
		Occlusion = surf.Occlusion;
		Alpha = surf.Alpha;
		AlphaClipThreshold = surf.AlphaClipThreshold;

		InputData inputData;
		inputData.positionWS = WorldSpacePosition;

#ifdef _NORMALMAP
		inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
#else
	#if !SHADER_HINT_NICE_QUALITY
		inputData.normalWS = WorldSpaceNormal;
	#else
		inputData.normalWS = normalize(WorldSpaceNormal);
	#endif
#endif

#if !SHADER_HINT_NICE_QUALITY
		// viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
		inputData.viewDirectionWS = WorldSpaceViewDirection;
#else
		inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
#endif

		inputData.shadowCoord = IN.shadowCoord;

		inputData.fogCoord = IN.fogFactorAndVertexLight.x;
		inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
		inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

		half4 color = LightweightFragmentPBR(
			inputData,
			Albedo,
			Metallic,
			Specular,
			Smoothness,
			Occlusion,
			Emission,
			Alpha);

		// Computes fog factor per-vertex
		color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);

#if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
		return color;
	}

	ENDHLSL
}
Pass
{
	Name "ShadowCaster"
	Tags{"LightMode" = "ShadowCaster"}

	ZWrite On ZTest LEqual

		// Material options generated by graph
		Cull Back

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex ShadowPassVertex
		#pragma fragment ShadowPassFragment

		// Defines generated by graph
		#define _SPECULAR_SETUP 1
		#define _AlphaClip 1

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float _AlphaClipping;
		float4 _Specular;
		float _WindPower;
		float3 _WindDirection;
		CBUFFER_END

		TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
		TEXTURE2D(_AlphaTexture); SAMPLER(sampler_AlphaTexture); float4 _AlphaTexture_TexelSize;
		SAMPLER(_SampleTexture2DLOD_BBB0CEFD_Sampler_3_Linear_Repeat);
		SAMPLER(_SampleTexture2D_1A51F6F2_Sampler_3_Linear_Repeat);
		struct VertexDescriptionInputs
		{
			float3 WorldSpacePosition;
			half4 uv0;
			float3 TimeParameters;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			half4 uv0;
		};


		void Unity_Multiply_float(float A, float B, out float Out)
		{
			Out = A * B;
		}

		void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
		{
			Out = UV * Tiling + Offset;
		}


	float2 Unity_GradientNoise_Dir_float(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}

		void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
		{
			float2 p = UV * Scale;
			float2 ip = floor(p);
			float2 fp = frac(p);
			float d00 = dot(Unity_GradientNoise_Dir_float(ip), fp);
			float d01 = dot(Unity_GradientNoise_Dir_float(ip + float2(0, 1)), fp - float2(0, 1));
			float d10 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 0)), fp - float2(1, 0));
			float d11 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 1)), fp - float2(1, 1));
			fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
			Out = lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x) + 0.5;
		}

		void Unity_Subtract_float(float A, float B, out float Out)
		{
			Out = A - B;
		}

		void Unity_Add_float(float A, float B, out float Out)
		{
			Out = A + B;
		}

		void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
		{
			RGBA = float4(R, G, B, A);
			RGB = float3(R, G, B);
			RG = float2(R, G);
		}

		void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
		{
			Out = A * B;
		}

		void Unity_Add_float3(float3 A, float3 B, out float3 Out)
		{
			Out = A + B;
		}

		void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
		{
			Out = lerp(A, B, T);
		}

		struct VertexDescription
		{
			float3 Position;
		};

		VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
		{
			VertexDescription description = (VertexDescription)0;
			float _Property_2BE6DF39_Out_0 = _WindPower;
			float _Multiply_545D4021_Out_2;
			Unity_Multiply_float(IN.TimeParameters.x, _Property_2BE6DF39_Out_0, _Multiply_545D4021_Out_2);
			float2 _TilingAndOffset_9889ABE_Out_3;
			Unity_TilingAndOffset_float((IN.WorldSpacePosition.xy), float2 (1, 1), (_Multiply_545D4021_Out_2.xx), _TilingAndOffset_9889ABE_Out_3);
			float _GradientNoise_AFB7D3BF_Out_2;
			Unity_GradientNoise_float(_TilingAndOffset_9889ABE_Out_3, 2, _GradientNoise_AFB7D3BF_Out_2);
			float _Subtract_1F2EE5A7_Out_2;
			Unity_Subtract_float(_GradientNoise_AFB7D3BF_Out_2, 0.5, _Subtract_1F2EE5A7_Out_2);
			float _Multiply_1BAD01C0_Out_2;
			Unity_Multiply_float(_Subtract_1F2EE5A7_Out_2, 0.3, _Multiply_1BAD01C0_Out_2);
			float _Split_DE0131F3_R_1 = IN.WorldSpacePosition[0];
			float _Split_DE0131F3_G_2 = IN.WorldSpacePosition[1];
			float _Split_DE0131F3_B_3 = IN.WorldSpacePosition[2];
			float _Split_DE0131F3_A_4 = 0;
			float _Add_C5B701FE_Out_2;
			Unity_Add_float(_Multiply_1BAD01C0_Out_2, _Split_DE0131F3_R_1, _Add_C5B701FE_Out_2);
			float4 _Combine_F661715B_RGBA_4;
			float3 _Combine_F661715B_RGB_5;
			float2 _Combine_F661715B_RG_6;
			Unity_Combine_float(_Add_C5B701FE_Out_2, _Split_DE0131F3_G_2, _Split_DE0131F3_B_3, 0, _Combine_F661715B_RGBA_4, _Combine_F661715B_RGB_5, _Combine_F661715B_RG_6);
			float3 _Property_B33F094A_Out_0 = _WindDirection;
			float _Property_DBEE1A40_Out_0 = _WindPower;
			float3 _Multiply_65493060_Out_2;
			Unity_Multiply_float(_Property_B33F094A_Out_0, (_Property_DBEE1A40_Out_0.xxx), _Multiply_65493060_Out_2);
			float _Vector1_6FC841E9_Out_0 = 0.2;
			float3 _Multiply_E197D81D_Out_2;
			Unity_Multiply_float(_Multiply_65493060_Out_2, (_Vector1_6FC841E9_Out_0.xxx), _Multiply_E197D81D_Out_2);
			float3 _Add_380B9076_Out_2;
			Unity_Add_float3((_Combine_F661715B_RGBA_4.xyz), _Multiply_E197D81D_Out_2, _Add_380B9076_Out_2);
			float4 _UV_8CAD4B4D_Out_0 = IN.uv0;
			float4 _SampleTexture2DLOD_BBB0CEFD_RGBA_0 = SAMPLE_TEXTURE2D_LOD(_AlphaTexture, sampler_AlphaTexture, (_UV_8CAD4B4D_Out_0.xy), 0);
			float _SampleTexture2DLOD_BBB0CEFD_R_5 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.r;
			float _SampleTexture2DLOD_BBB0CEFD_G_6 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.g;
			float _SampleTexture2DLOD_BBB0CEFD_B_7 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.b;
			float _SampleTexture2DLOD_BBB0CEFD_A_8 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.a;
			float3 _Lerp_598583DA_Out_3;
			Unity_Lerp_float3(IN.WorldSpacePosition, _Add_380B9076_Out_2, (_SampleTexture2DLOD_BBB0CEFD_G_6.xxx), _Lerp_598583DA_Out_3);
			description.Position = _Lerp_598583DA_Out_3;
			return description;
		}

		struct SurfaceDescription
		{
			float3 Albedo;
			float3 Emission;
			float Alpha;
			float AlphaClipThreshold;
		};

		SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
		{
			SurfaceDescription surface = (SurfaceDescription)0;
			float4 _SampleTexture2D_1A51F6F2_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, IN.uv0.xy);
			float _SampleTexture2D_1A51F6F2_R_4 = _SampleTexture2D_1A51F6F2_RGBA_0.r;
			float _SampleTexture2D_1A51F6F2_G_5 = _SampleTexture2D_1A51F6F2_RGBA_0.g;
			float _SampleTexture2D_1A51F6F2_B_6 = _SampleTexture2D_1A51F6F2_RGBA_0.b;
			float _SampleTexture2D_1A51F6F2_A_7 = _SampleTexture2D_1A51F6F2_RGBA_0.a;
			float _Property_77F583FF_Out_0 = _AlphaClipping;
			surface.Albedo = (_SampleTexture2D_1A51F6F2_RGBA_0.xyz);
			surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
			surface.Alpha = _SampleTexture2D_1A51F6F2_A_7;
			surface.AlphaClipThreshold = _Property_77F583FF_Out_0;
			return surface;
		}

		struct GraphVertexInput
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float4 tangent : TANGENT;
			float4 texcoord0 : TEXCOORD0;
			float4 texcoord1 : TEXCOORD1;
			UNITY_VERTEX_INPUT_INSTANCE_ID
		};


		struct VertexOutput
		{
			float2 uv           : TEXCOORD0;
			float4 clipPos      : SV_POSITION;
			// Interpolators defined by graph
			float3 WorldSpacePosition : TEXCOORD3;
			float3 WorldSpaceNormal : TEXCOORD4;
			float3 WorldSpaceTangent : TEXCOORD5;
			float3 WorldSpaceBiTangent : TEXCOORD6;
			float3 WorldSpaceViewDirection : TEXCOORD7;
			half4 uv0 : TEXCOORD8;
			half4 uv1 : TEXCOORD9;

			UNITY_VERTEX_INPUT_INSTANCE_ID
		};

		float3 _LightDirection;

		VertexOutput ShadowPassVertex(GraphVertexInput v)
		{
			VertexOutput o;
			UNITY_SETUP_INSTANCE_ID(v);
			UNITY_TRANSFER_INSTANCE_ID(v, o);

			// Vertex transformations performed by graph
			float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
			float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
			float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
			float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
			float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
			float4 uv0 = v.texcoord0;
			float4 uv1 = v.texcoord1;

			VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

			// Vertex description inputs defined by graph
			vdi.WorldSpacePosition = WorldSpacePosition;
			vdi.uv0 = uv0;
			vdi.TimeParameters = _TimeParameters.xyz;

			VertexDescription vd = PopulateVertexData(vdi);
			v.vertex.xyz = vd.Position;

			// Vertex shader outputs defined by graph
			o.WorldSpacePosition = WorldSpacePosition;
			o.WorldSpaceNormal = WorldSpaceNormal;
			o.WorldSpaceTangent = WorldSpaceTangent;
			o.WorldSpaceBiTangent = WorldSpaceBiTangent;
			o.WorldSpaceViewDirection = WorldSpaceViewDirection;
			o.uv0 = uv0;
			o.uv1 = uv1;


			float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
			float3 normalWS = TransformObjectToWorldNormal(v.normal);

			float4 clipPos = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection));

		#if UNITY_REVERSED_Z
			clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
		#else
			clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
		#endif
			o.clipPos = clipPos;

			return o;
		}

		half4 ShadowPassFragment(VertexOutput IN) : SV_TARGET
		{
			UNITY_SETUP_INSTANCE_ID(IN);

		// Pixel transformations performed by graph
		float3 WorldSpacePosition = IN.WorldSpacePosition;
		float3 WorldSpaceNormal = IN.WorldSpaceNormal;
		float3 WorldSpaceTangent = IN.WorldSpaceTangent;
		float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
		float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
		float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
		float4 uv0 = IN.uv0;
		float4 uv1 = IN.uv1;
		float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

		SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
		surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
		surfaceInput.uv0 = uv0;

		SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

		float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Emission = 0;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
		Albedo = surf.Albedo;
		Emission = surf.Emission;
		Alpha = surf.Alpha;
		AlphaClipThreshold = surf.AlphaClipThreshold;

 #if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
		return 0;
	}

	ENDHLSL
}

Pass
{
	Name "DepthOnly"
	Tags{"LightMode" = "DepthOnly"}

	ZWrite On
	ColorMask 0

		// Material options generated by graph
		Cull Back

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex vert
		#pragma fragment frag

		// Defines generated by graph
		#define _SPECULAR_SETUP 1
		#define _AlphaClip 1

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float _AlphaClipping;
		float4 _Specular;
		float _WindPower;
		float3 _WindDirection;
		CBUFFER_END

		TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
		TEXTURE2D(_AlphaTexture); SAMPLER(sampler_AlphaTexture); float4 _AlphaTexture_TexelSize;
		SAMPLER(_SampleTexture2DLOD_BBB0CEFD_Sampler_3_Linear_Repeat);
		SAMPLER(_SampleTexture2D_1A51F6F2_Sampler_3_Linear_Repeat);
		struct VertexDescriptionInputs
		{
			float3 WorldSpacePosition;
			half4 uv0;
			float3 TimeParameters;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			half4 uv0;
		};


		void Unity_Multiply_float(float A, float B, out float Out)
		{
			Out = A * B;
		}

		void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
		{
			Out = UV * Tiling + Offset;
		}


	float2 Unity_GradientNoise_Dir_float(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}

		void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
		{
			float2 p = UV * Scale;
			float2 ip = floor(p);
			float2 fp = frac(p);
			float d00 = dot(Unity_GradientNoise_Dir_float(ip), fp);
			float d01 = dot(Unity_GradientNoise_Dir_float(ip + float2(0, 1)), fp - float2(0, 1));
			float d10 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 0)), fp - float2(1, 0));
			float d11 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 1)), fp - float2(1, 1));
			fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
			Out = lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x) + 0.5;
		}

		void Unity_Subtract_float(float A, float B, out float Out)
		{
			Out = A - B;
		}

		void Unity_Add_float(float A, float B, out float Out)
		{
			Out = A + B;
		}

		void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
		{
			RGBA = float4(R, G, B, A);
			RGB = float3(R, G, B);
			RG = float2(R, G);
		}

		void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
		{
			Out = A * B;
		}

		void Unity_Add_float3(float3 A, float3 B, out float3 Out)
		{
			Out = A + B;
		}

		void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
		{
			Out = lerp(A, B, T);
		}

		struct VertexDescription
		{
			float3 Position;
		};

		VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
		{
			VertexDescription description = (VertexDescription)0;
			float _Property_2BE6DF39_Out_0 = _WindPower;
			float _Multiply_545D4021_Out_2;
			Unity_Multiply_float(IN.TimeParameters.x, _Property_2BE6DF39_Out_0, _Multiply_545D4021_Out_2);
			float2 _TilingAndOffset_9889ABE_Out_3;
			Unity_TilingAndOffset_float((IN.WorldSpacePosition.xy), float2 (1, 1), (_Multiply_545D4021_Out_2.xx), _TilingAndOffset_9889ABE_Out_3);
			float _GradientNoise_AFB7D3BF_Out_2;
			Unity_GradientNoise_float(_TilingAndOffset_9889ABE_Out_3, 2, _GradientNoise_AFB7D3BF_Out_2);
			float _Subtract_1F2EE5A7_Out_2;
			Unity_Subtract_float(_GradientNoise_AFB7D3BF_Out_2, 0.5, _Subtract_1F2EE5A7_Out_2);
			float _Multiply_1BAD01C0_Out_2;
			Unity_Multiply_float(_Subtract_1F2EE5A7_Out_2, 0.3, _Multiply_1BAD01C0_Out_2);
			float _Split_DE0131F3_R_1 = IN.WorldSpacePosition[0];
			float _Split_DE0131F3_G_2 = IN.WorldSpacePosition[1];
			float _Split_DE0131F3_B_3 = IN.WorldSpacePosition[2];
			float _Split_DE0131F3_A_4 = 0;
			float _Add_C5B701FE_Out_2;
			Unity_Add_float(_Multiply_1BAD01C0_Out_2, _Split_DE0131F3_R_1, _Add_C5B701FE_Out_2);
			float4 _Combine_F661715B_RGBA_4;
			float3 _Combine_F661715B_RGB_5;
			float2 _Combine_F661715B_RG_6;
			Unity_Combine_float(_Add_C5B701FE_Out_2, _Split_DE0131F3_G_2, _Split_DE0131F3_B_3, 0, _Combine_F661715B_RGBA_4, _Combine_F661715B_RGB_5, _Combine_F661715B_RG_6);
			float3 _Property_B33F094A_Out_0 = _WindDirection;
			float _Property_DBEE1A40_Out_0 = _WindPower;
			float3 _Multiply_65493060_Out_2;
			Unity_Multiply_float(_Property_B33F094A_Out_0, (_Property_DBEE1A40_Out_0.xxx), _Multiply_65493060_Out_2);
			float _Vector1_6FC841E9_Out_0 = 0.2;
			float3 _Multiply_E197D81D_Out_2;
			Unity_Multiply_float(_Multiply_65493060_Out_2, (_Vector1_6FC841E9_Out_0.xxx), _Multiply_E197D81D_Out_2);
			float3 _Add_380B9076_Out_2;
			Unity_Add_float3((_Combine_F661715B_RGBA_4.xyz), _Multiply_E197D81D_Out_2, _Add_380B9076_Out_2);
			float4 _UV_8CAD4B4D_Out_0 = IN.uv0;
			float4 _SampleTexture2DLOD_BBB0CEFD_RGBA_0 = SAMPLE_TEXTURE2D_LOD(_AlphaTexture, sampler_AlphaTexture, (_UV_8CAD4B4D_Out_0.xy), 0);
			float _SampleTexture2DLOD_BBB0CEFD_R_5 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.r;
			float _SampleTexture2DLOD_BBB0CEFD_G_6 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.g;
			float _SampleTexture2DLOD_BBB0CEFD_B_7 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.b;
			float _SampleTexture2DLOD_BBB0CEFD_A_8 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.a;
			float3 _Lerp_598583DA_Out_3;
			Unity_Lerp_float3(IN.WorldSpacePosition, _Add_380B9076_Out_2, (_SampleTexture2DLOD_BBB0CEFD_G_6.xxx), _Lerp_598583DA_Out_3);
			description.Position = _Lerp_598583DA_Out_3;
			return description;
		}

		struct SurfaceDescription
		{
			float3 Albedo;
			float3 Emission;
			float Alpha;
			float AlphaClipThreshold;
		};

		SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
		{
			SurfaceDescription surface = (SurfaceDescription)0;
			float4 _SampleTexture2D_1A51F6F2_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, IN.uv0.xy);
			float _SampleTexture2D_1A51F6F2_R_4 = _SampleTexture2D_1A51F6F2_RGBA_0.r;
			float _SampleTexture2D_1A51F6F2_G_5 = _SampleTexture2D_1A51F6F2_RGBA_0.g;
			float _SampleTexture2D_1A51F6F2_B_6 = _SampleTexture2D_1A51F6F2_RGBA_0.b;
			float _SampleTexture2D_1A51F6F2_A_7 = _SampleTexture2D_1A51F6F2_RGBA_0.a;
			float _Property_77F583FF_Out_0 = _AlphaClipping;
			surface.Albedo = (_SampleTexture2D_1A51F6F2_RGBA_0.xyz);
			surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
			surface.Alpha = _SampleTexture2D_1A51F6F2_A_7;
			surface.AlphaClipThreshold = _Property_77F583FF_Out_0;
			return surface;
		}

		struct GraphVertexInput
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float4 tangent : TANGENT;
			float4 texcoord0 : TEXCOORD0;
			float4 texcoord1 : TEXCOORD1;
			UNITY_VERTEX_INPUT_INSTANCE_ID
		};


		struct VertexOutput
		{
			float2 uv           : TEXCOORD0;
			float4 clipPos      : SV_POSITION;
			// Interpolators defined by graph
			float3 WorldSpacePosition : TEXCOORD3;
			float3 WorldSpaceNormal : TEXCOORD4;
			float3 WorldSpaceTangent : TEXCOORD5;
			float3 WorldSpaceBiTangent : TEXCOORD6;
			float3 WorldSpaceViewDirection : TEXCOORD7;
			half4 uv0 : TEXCOORD8;
			half4 uv1 : TEXCOORD9;

			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
		};

		VertexOutput vert(GraphVertexInput v)
		{
			VertexOutput o = (VertexOutput)0;
			UNITY_SETUP_INSTANCE_ID(v);
			UNITY_TRANSFER_INSTANCE_ID(v, o);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

			// Vertex transformations performed by graph
			float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
			float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
			float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
			float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
			float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
			float4 uv0 = v.texcoord0;
			float4 uv1 = v.texcoord1;

			VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

			// Vertex description inputs defined by graph
			vdi.WorldSpacePosition = WorldSpacePosition;
			vdi.uv0 = uv0;
			vdi.TimeParameters = _TimeParameters.xyz;

			VertexDescription vd = PopulateVertexData(vdi);
			v.vertex.xyz = vd.Position;

			// Vertex shader outputs defined by graph
			o.WorldSpacePosition = WorldSpacePosition;
			o.WorldSpaceNormal = WorldSpaceNormal;
			o.WorldSpaceTangent = WorldSpaceTangent;
			o.WorldSpaceBiTangent = WorldSpaceBiTangent;
			o.WorldSpaceViewDirection = WorldSpaceViewDirection;
			o.uv0 = uv0;
			o.uv1 = uv1;

			o.clipPos = TransformObjectToHClip(v.vertex.xyz);
			return o;
		}

		half4 frag(VertexOutput IN) : SV_TARGET
		{
			UNITY_SETUP_INSTANCE_ID(IN);
			UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

			// Pixel transformations performed by graph
			float3 WorldSpacePosition = IN.WorldSpacePosition;
			float3 WorldSpaceNormal = IN.WorldSpaceNormal;
			float3 WorldSpaceTangent = IN.WorldSpaceTangent;
			float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
			float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
			float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
			float4 uv0 = IN.uv0;
			float4 uv1 = IN.uv1;
			float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

			SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

			// Surface description inputs defined by graph
			surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
			surfaceInput.uv0 = uv0;

			SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

			float3 Albedo = float3(0.5, 0.5, 0.5);
			float3 Emission = 0;
			float Alpha = 1;
			float AlphaClipThreshold = 0;

			// Surface description remap performed by graph
			Albedo = surf.Albedo;
			Emission = surf.Emission;
			Alpha = surf.Alpha;
			AlphaClipThreshold = surf.AlphaClipThreshold;

	 #if _AlphaClip
			clip(Alpha - AlphaClipThreshold);
	#endif
			return 0;
		}
		ENDHLSL
	}

		// This pass it not used during regular rendering, only for lightmap baking.
		Pass
		{
			Name "Meta"
			Tags{"LightMode" = "Meta"}

			Cull Off

			HLSLPROGRAM
			// Required to compile gles 2.0 with standard srp library
			#pragma prefer_hlslcc gles
			#pragma exclude_renderers d3d11_9x
			#pragma target 2.0

			#pragma vertex vert
			#pragma fragment frag

			float4 _MainTex_ST;

		// Defines generated by graph
		#define _SPECULAR_SETUP 1
		#define _AlphaClip 1

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		#pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

			CBUFFER_START(UnityPerMaterial)
		float _AlphaClipping;
		float4 _Specular;
		float _WindPower;
		float3 _WindDirection;
		CBUFFER_END

		TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
		TEXTURE2D(_AlphaTexture); SAMPLER(sampler_AlphaTexture); float4 _AlphaTexture_TexelSize;
		SAMPLER(_SampleTexture2DLOD_BBB0CEFD_Sampler_3_Linear_Repeat);
		SAMPLER(_SampleTexture2D_1A51F6F2_Sampler_3_Linear_Repeat);
		struct VertexDescriptionInputs
		{
			float3 WorldSpacePosition;
			half4 uv0;
			float3 TimeParameters;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			half4 uv0;
		};


		void Unity_Multiply_float(float A, float B, out float Out)
		{
			Out = A * B;
		}

		void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
		{
			Out = UV * Tiling + Offset;
		}


	float2 Unity_GradientNoise_Dir_float(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}

		void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
		{
			float2 p = UV * Scale;
			float2 ip = floor(p);
			float2 fp = frac(p);
			float d00 = dot(Unity_GradientNoise_Dir_float(ip), fp);
			float d01 = dot(Unity_GradientNoise_Dir_float(ip + float2(0, 1)), fp - float2(0, 1));
			float d10 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 0)), fp - float2(1, 0));
			float d11 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 1)), fp - float2(1, 1));
			fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
			Out = lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x) + 0.5;
		}

		void Unity_Subtract_float(float A, float B, out float Out)
		{
			Out = A - B;
		}

		void Unity_Add_float(float A, float B, out float Out)
		{
			Out = A + B;
		}

		void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
		{
			RGBA = float4(R, G, B, A);
			RGB = float3(R, G, B);
			RG = float2(R, G);
		}

		void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
		{
			Out = A * B;
		}

		void Unity_Add_float3(float3 A, float3 B, out float3 Out)
		{
			Out = A + B;
		}

		void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
		{
			Out = lerp(A, B, T);
		}

		struct VertexDescription
		{
			float3 Position;
		};

		VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
		{
			VertexDescription description = (VertexDescription)0;
			float _Property_2BE6DF39_Out_0 = _WindPower;
			float _Multiply_545D4021_Out_2;
			Unity_Multiply_float(IN.TimeParameters.x, _Property_2BE6DF39_Out_0, _Multiply_545D4021_Out_2);
			float2 _TilingAndOffset_9889ABE_Out_3;
			Unity_TilingAndOffset_float((IN.WorldSpacePosition.xy), float2 (1, 1), (_Multiply_545D4021_Out_2.xx), _TilingAndOffset_9889ABE_Out_3);
			float _GradientNoise_AFB7D3BF_Out_2;
			Unity_GradientNoise_float(_TilingAndOffset_9889ABE_Out_3, 2, _GradientNoise_AFB7D3BF_Out_2);
			float _Subtract_1F2EE5A7_Out_2;
			Unity_Subtract_float(_GradientNoise_AFB7D3BF_Out_2, 0.5, _Subtract_1F2EE5A7_Out_2);
			float _Multiply_1BAD01C0_Out_2;
			Unity_Multiply_float(_Subtract_1F2EE5A7_Out_2, 0.3, _Multiply_1BAD01C0_Out_2);
			float _Split_DE0131F3_R_1 = IN.WorldSpacePosition[0];
			float _Split_DE0131F3_G_2 = IN.WorldSpacePosition[1];
			float _Split_DE0131F3_B_3 = IN.WorldSpacePosition[2];
			float _Split_DE0131F3_A_4 = 0;
			float _Add_C5B701FE_Out_2;
			Unity_Add_float(_Multiply_1BAD01C0_Out_2, _Split_DE0131F3_R_1, _Add_C5B701FE_Out_2);
			float4 _Combine_F661715B_RGBA_4;
			float3 _Combine_F661715B_RGB_5;
			float2 _Combine_F661715B_RG_6;
			Unity_Combine_float(_Add_C5B701FE_Out_2, _Split_DE0131F3_G_2, _Split_DE0131F3_B_3, 0, _Combine_F661715B_RGBA_4, _Combine_F661715B_RGB_5, _Combine_F661715B_RG_6);
			float3 _Property_B33F094A_Out_0 = _WindDirection;
			float _Property_DBEE1A40_Out_0 = _WindPower;
			float3 _Multiply_65493060_Out_2;
			Unity_Multiply_float(_Property_B33F094A_Out_0, (_Property_DBEE1A40_Out_0.xxx), _Multiply_65493060_Out_2);
			float _Vector1_6FC841E9_Out_0 = 0.2;
			float3 _Multiply_E197D81D_Out_2;
			Unity_Multiply_float(_Multiply_65493060_Out_2, (_Vector1_6FC841E9_Out_0.xxx), _Multiply_E197D81D_Out_2);
			float3 _Add_380B9076_Out_2;
			Unity_Add_float3((_Combine_F661715B_RGBA_4.xyz), _Multiply_E197D81D_Out_2, _Add_380B9076_Out_2);
			float4 _UV_8CAD4B4D_Out_0 = IN.uv0;
			float4 _SampleTexture2DLOD_BBB0CEFD_RGBA_0 = SAMPLE_TEXTURE2D_LOD(_AlphaTexture, sampler_AlphaTexture, (_UV_8CAD4B4D_Out_0.xy), 0);
			float _SampleTexture2DLOD_BBB0CEFD_R_5 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.r;
			float _SampleTexture2DLOD_BBB0CEFD_G_6 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.g;
			float _SampleTexture2DLOD_BBB0CEFD_B_7 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.b;
			float _SampleTexture2DLOD_BBB0CEFD_A_8 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.a;
			float3 _Lerp_598583DA_Out_3;
			Unity_Lerp_float3(IN.WorldSpacePosition, _Add_380B9076_Out_2, (_SampleTexture2DLOD_BBB0CEFD_G_6.xxx), _Lerp_598583DA_Out_3);
			description.Position = _Lerp_598583DA_Out_3;
			return description;
		}

		struct SurfaceDescription
		{
			float3 Albedo;
			float3 Emission;
			float Alpha;
			float AlphaClipThreshold;
		};

		SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
		{
			SurfaceDescription surface = (SurfaceDescription)0;
			float4 _SampleTexture2D_1A51F6F2_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, IN.uv0.xy);
			float _SampleTexture2D_1A51F6F2_R_4 = _SampleTexture2D_1A51F6F2_RGBA_0.r;
			float _SampleTexture2D_1A51F6F2_G_5 = _SampleTexture2D_1A51F6F2_RGBA_0.g;
			float _SampleTexture2D_1A51F6F2_B_6 = _SampleTexture2D_1A51F6F2_RGBA_0.b;
			float _SampleTexture2D_1A51F6F2_A_7 = _SampleTexture2D_1A51F6F2_RGBA_0.a;
			float _Property_77F583FF_Out_0 = _AlphaClipping;
			surface.Albedo = (_SampleTexture2D_1A51F6F2_RGBA_0.xyz);
			surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
			surface.Alpha = _SampleTexture2D_1A51F6F2_A_7;
			surface.AlphaClipThreshold = _Property_77F583FF_Out_0;
			return surface;
		}

		struct GraphVertexInput
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float4 tangent : TANGENT;
			float4 texcoord0 : TEXCOORD0;
			float4 texcoord1 : TEXCOORD1;
			UNITY_VERTEX_INPUT_INSTANCE_ID
		};


		struct VertexOutput
		{
			float2 uv           : TEXCOORD0;
			float4 clipPos      : SV_POSITION;
			// Interpolators defined by graph
			float3 WorldSpacePosition : TEXCOORD3;
			float3 WorldSpaceNormal : TEXCOORD4;
			float3 WorldSpaceTangent : TEXCOORD5;
			float3 WorldSpaceBiTangent : TEXCOORD6;
			float3 WorldSpaceViewDirection : TEXCOORD7;
			half4 uv0 : TEXCOORD8;
			half4 uv1 : TEXCOORD9;

			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
		};

		VertexOutput vert(GraphVertexInput v)
		{
			VertexOutput o = (VertexOutput)0;
			UNITY_SETUP_INSTANCE_ID(v);
			UNITY_TRANSFER_INSTANCE_ID(v, o);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

			// Vertex transformations performed by graph
			float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
			float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
			float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
			float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
			float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
			float4 uv0 = v.texcoord0;
			float4 uv1 = v.texcoord1;


			// Vertex shader outputs defined by graph
			o.WorldSpacePosition = WorldSpacePosition;
			o.WorldSpaceNormal = WorldSpaceNormal;
			o.WorldSpaceTangent = WorldSpaceTangent;
			o.WorldSpaceBiTangent = WorldSpaceBiTangent;
			o.WorldSpaceViewDirection = WorldSpaceViewDirection;
			o.uv0 = uv0;
			o.uv1 = uv1;

			o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST, unity_DynamicLightmapST);
			return o;
		}

		half4 frag(VertexOutput IN) : SV_TARGET
		{
			UNITY_SETUP_INSTANCE_ID(IN);
			UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

			// Pixel transformations performed by graph
			float3 WorldSpacePosition = IN.WorldSpacePosition;
			float3 WorldSpaceNormal = IN.WorldSpaceNormal;
			float3 WorldSpaceTangent = IN.WorldSpaceTangent;
			float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
			float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
			float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
			float4 uv0 = IN.uv0;
			float4 uv1 = IN.uv1;
			float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

			SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

			// Surface description inputs defined by graph
			surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
			surfaceInput.uv0 = uv0;

			SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

			float3 Albedo = float3(0.5, 0.5, 0.5);
			float3 Emission = 0;
			float Alpha = 1;
			float AlphaClipThreshold = 0;

			// Surface description remap performed by graph
			Albedo = surf.Albedo;
			Emission = surf.Emission;
			Alpha = surf.Alpha;
			AlphaClipThreshold = surf.AlphaClipThreshold;

	 #if _AlphaClip
			clip(Alpha - AlphaClipThreshold);
	#endif

			MetaInput metaInput = (MetaInput)0;
			metaInput.Albedo = Albedo;
			metaInput.Emission = Emission;

			return MetaFragment(metaInput);
		}
		ENDHLSL
	}
	Pass
	{
		Tags{"LightMode" = "Lightweight2D"}

		// Material options generated by graph

		Blend One Zero, One Zero

		Cull Back

		ZTest LEqual

		ZWrite On

		HLSLPROGRAM
			// Required to compile gles 2.0 with standard srp library
			#pragma enable_d3d11_debug_symbols
			#pragma prefer_hlslcc gles
			#pragma exclude_renderers d3d11_9x
			#pragma target 2.0

			#pragma vertex vert
			#pragma fragment frag

			// Defines generated by graph
			#define _SPECULAR_SETUP 1
			#define _AlphaClip 1

			#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
			#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
			#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
			#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
			#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

			CBUFFER_START(UnityPerMaterial)
			float _AlphaClipping;
			float4 _Specular;
			float _WindPower;
			float3 _WindDirection;
			CBUFFER_END

			TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
			TEXTURE2D(_AlphaTexture); SAMPLER(sampler_AlphaTexture); float4 _AlphaTexture_TexelSize;
			SAMPLER(_SampleTexture2DLOD_BBB0CEFD_Sampler_3_Linear_Repeat);
			SAMPLER(_SampleTexture2D_1A51F6F2_Sampler_3_Linear_Repeat);
			struct VertexDescriptionInputs
			{
				float3 WorldSpacePosition;
				half4 uv0;
				float3 TimeParameters;
			};

			struct SurfaceDescriptionInputs
			{
				float3 TangentSpaceNormal;
				half4 uv0;
			};


			void Unity_Multiply_float(float A, float B, out float Out)
			{
				Out = A * B;
			}

			void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
			{
				Out = UV * Tiling + Offset;
			}


		float2 Unity_GradientNoise_Dir_float(float2 p)
		{
			// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
			p = p % 289;
			float x = (34 * p.x + 1) * p.x % 289 + p.y;
			x = (34 * x + 1) * x % 289;
			x = frac(x / 41) * 2 - 1;
			return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
		}

			void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
			{
				float2 p = UV * Scale;
				float2 ip = floor(p);
				float2 fp = frac(p);
				float d00 = dot(Unity_GradientNoise_Dir_float(ip), fp);
				float d01 = dot(Unity_GradientNoise_Dir_float(ip + float2(0, 1)), fp - float2(0, 1));
				float d10 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 0)), fp - float2(1, 0));
				float d11 = dot(Unity_GradientNoise_Dir_float(ip + float2(1, 1)), fp - float2(1, 1));
				fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
				Out = lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x) + 0.5;
			}

			void Unity_Subtract_float(float A, float B, out float Out)
			{
				Out = A - B;
			}

			void Unity_Add_float(float A, float B, out float Out)
			{
				Out = A + B;
			}

			void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
			{
				RGBA = float4(R, G, B, A);
				RGB = float3(R, G, B);
				RG = float2(R, G);
			}

			void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
			{
				Out = A * B;
			}

			void Unity_Add_float3(float3 A, float3 B, out float3 Out)
			{
				Out = A + B;
			}

			void Unity_Lerp_float3(float3 A, float3 B, float3 T, out float3 Out)
			{
				Out = lerp(A, B, T);
			}

			struct VertexDescription
			{
				float3 Position;
			};

			VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
			{
				VertexDescription description = (VertexDescription)0;
				float _Property_2BE6DF39_Out_0 = _WindPower;
				float _Multiply_545D4021_Out_2;
				Unity_Multiply_float(IN.TimeParameters.x, _Property_2BE6DF39_Out_0, _Multiply_545D4021_Out_2);
				float2 _TilingAndOffset_9889ABE_Out_3;
				Unity_TilingAndOffset_float((IN.WorldSpacePosition.xy), float2 (1, 1), (_Multiply_545D4021_Out_2.xx), _TilingAndOffset_9889ABE_Out_3);
				float _GradientNoise_AFB7D3BF_Out_2;
				Unity_GradientNoise_float(_TilingAndOffset_9889ABE_Out_3, 2, _GradientNoise_AFB7D3BF_Out_2);
				float _Subtract_1F2EE5A7_Out_2;
				Unity_Subtract_float(_GradientNoise_AFB7D3BF_Out_2, 0.5, _Subtract_1F2EE5A7_Out_2);
				float _Multiply_1BAD01C0_Out_2;
				Unity_Multiply_float(_Subtract_1F2EE5A7_Out_2, 0.3, _Multiply_1BAD01C0_Out_2);
				float _Split_DE0131F3_R_1 = IN.WorldSpacePosition[0];
				float _Split_DE0131F3_G_2 = IN.WorldSpacePosition[1];
				float _Split_DE0131F3_B_3 = IN.WorldSpacePosition[2];
				float _Split_DE0131F3_A_4 = 0;
				float _Add_C5B701FE_Out_2;
				Unity_Add_float(_Multiply_1BAD01C0_Out_2, _Split_DE0131F3_R_1, _Add_C5B701FE_Out_2);
				float4 _Combine_F661715B_RGBA_4;
				float3 _Combine_F661715B_RGB_5;
				float2 _Combine_F661715B_RG_6;
				Unity_Combine_float(_Add_C5B701FE_Out_2, _Split_DE0131F3_G_2, _Split_DE0131F3_B_3, 0, _Combine_F661715B_RGBA_4, _Combine_F661715B_RGB_5, _Combine_F661715B_RG_6);
				float3 _Property_B33F094A_Out_0 = _WindDirection;
				float _Property_DBEE1A40_Out_0 = _WindPower;
				float3 _Multiply_65493060_Out_2;
				Unity_Multiply_float(_Property_B33F094A_Out_0, (_Property_DBEE1A40_Out_0.xxx), _Multiply_65493060_Out_2);
				float _Vector1_6FC841E9_Out_0 = 0.2;
				float3 _Multiply_E197D81D_Out_2;
				Unity_Multiply_float(_Multiply_65493060_Out_2, (_Vector1_6FC841E9_Out_0.xxx), _Multiply_E197D81D_Out_2);
				float3 _Add_380B9076_Out_2;
				Unity_Add_float3((_Combine_F661715B_RGBA_4.xyz), _Multiply_E197D81D_Out_2, _Add_380B9076_Out_2);
				float4 _UV_8CAD4B4D_Out_0 = IN.uv0;
				float4 _SampleTexture2DLOD_BBB0CEFD_RGBA_0 = SAMPLE_TEXTURE2D_LOD(_AlphaTexture, sampler_AlphaTexture, (_UV_8CAD4B4D_Out_0.xy), 0);
				float _SampleTexture2DLOD_BBB0CEFD_R_5 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.r;
				float _SampleTexture2DLOD_BBB0CEFD_G_6 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.g;
				float _SampleTexture2DLOD_BBB0CEFD_B_7 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.b;
				float _SampleTexture2DLOD_BBB0CEFD_A_8 = _SampleTexture2DLOD_BBB0CEFD_RGBA_0.a;
				float3 _Lerp_598583DA_Out_3;
				Unity_Lerp_float3(IN.WorldSpacePosition, _Add_380B9076_Out_2, (_SampleTexture2DLOD_BBB0CEFD_G_6.xxx), _Lerp_598583DA_Out_3);
				description.Position = _Lerp_598583DA_Out_3;
				return description;
			}

			struct SurfaceDescription
			{
				float3 Albedo;
				float3 Normal;
				float3 Emission;
				float3 Specular;
				float Smoothness;
				float Occlusion;
				float Alpha;
				float AlphaClipThreshold;
			};

			SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
			{
				SurfaceDescription surface = (SurfaceDescription)0;
				float4 _SampleTexture2D_1A51F6F2_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, IN.uv0.xy);
				float _SampleTexture2D_1A51F6F2_R_4 = _SampleTexture2D_1A51F6F2_RGBA_0.r;
				float _SampleTexture2D_1A51F6F2_G_5 = _SampleTexture2D_1A51F6F2_RGBA_0.g;
				float _SampleTexture2D_1A51F6F2_B_6 = _SampleTexture2D_1A51F6F2_RGBA_0.b;
				float _SampleTexture2D_1A51F6F2_A_7 = _SampleTexture2D_1A51F6F2_RGBA_0.a;
				float4 _Property_91DFE63F_Out_0 = _Specular;
				float _Property_77F583FF_Out_0 = _AlphaClipping;
				surface.Albedo = (_SampleTexture2D_1A51F6F2_RGBA_0.xyz);
				surface.Normal = IN.TangentSpaceNormal;
				surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
				surface.Specular = (_Property_91DFE63F_Out_0.xyz);
				surface.Smoothness = 0.5;
				surface.Occlusion = 1;
				surface.Alpha = _SampleTexture2D_1A51F6F2_A_7;
				surface.AlphaClipThreshold = _Property_77F583FF_Out_0;
				return surface;
			}

			struct GraphVertexInput
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
				float4 texcoord0 : TEXCOORD0;
				float4 texcoord1 : TEXCOORD1;
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};


			struct GraphVertexOutput
			{
				float4 clipPos                : SV_POSITION;
				// Interpolators defined by graph
				float3 WorldSpacePosition : TEXCOORD3;
				float3 WorldSpaceNormal : TEXCOORD4;
				float3 WorldSpaceTangent : TEXCOORD5;
				float3 WorldSpaceBiTangent : TEXCOORD6;
				float3 WorldSpaceViewDirection : TEXCOORD7;
				half4 uv0 : TEXCOORD8;
				half4 uv1 : TEXCOORD9;

			};

			GraphVertexOutput vert(GraphVertexInput v)
			{
				GraphVertexOutput o = (GraphVertexOutput)0;

				// Vertex transformations performed by graph
				float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
				float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
				float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
				float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
				float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
				float4 uv0 = v.texcoord0;
				float4 uv1 = v.texcoord1;

				VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

				// Vertex description inputs defined by graph
				vdi.WorldSpacePosition = WorldSpacePosition;
				vdi.uv0 = uv0;
				vdi.TimeParameters = _TimeParameters.xyz;

				VertexDescription vd = PopulateVertexData(vdi);
				v.vertex.xyz = vd.Position;

				// Vertex shader outputs defined by graph
				o.WorldSpacePosition = WorldSpacePosition;
				o.WorldSpaceNormal = WorldSpaceNormal;
				o.WorldSpaceTangent = WorldSpaceTangent;
				o.WorldSpaceBiTangent = WorldSpaceBiTangent;
				o.WorldSpaceViewDirection = WorldSpaceViewDirection;
				o.uv0 = uv0;
				o.uv1 = uv1;


				VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
				o.clipPos = vertexInput.positionCS;

				return o;
			}

			half4 frag(GraphVertexOutput IN) : SV_Target
			{
				// Pixel transformations performed by graph
				float3 WorldSpacePosition = IN.WorldSpacePosition;
				float3 WorldSpaceNormal = IN.WorldSpaceNormal;
				float3 WorldSpaceTangent = IN.WorldSpaceTangent;
				float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
				float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
				float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
				float4 uv0 = IN.uv0;
				float4 uv1 = IN.uv1;
				float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

				SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

				// Surface description inputs defined by graph
				surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
				surfaceInput.uv0 = uv0;

				SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

				float3 Albedo = float3(0.5, 0.5, 0.5);
				float3 Specular = float3(0, 0, 0);
				float Metallic = 1;
				float3 Normal = float3(0, 0, 1);
				float3 Emission = 0;
				float Smoothness = 0.5;
				float Occlusion = 1;
				float Alpha = 1;
				float AlphaClipThreshold = 0;

				// Surface description remap performed by graph
				Albedo = surf.Albedo;
				Normal = surf.Normal;
				Emission = surf.Emission;
				Specular = surf.Specular;
				Smoothness = surf.Smoothness;
				Occlusion = surf.Occlusion;
				Alpha = surf.Alpha;
				AlphaClipThreshold = surf.AlphaClipThreshold;


				// Computes fog factor per-vertex
				half4 color = half4(Albedo, Alpha);

		#if _AlphaClip
				clip(Alpha - AlphaClipThreshold);
		#endif
				return color;
			}

			ENDHLSL
		}
}
CustomEditor "UnityEditor.ShaderGraph.PBRMasterGUI"
FallBack "Hidden/InternalErrorShader"
}
