Shader "Custom/ObejctTransparentShader"
{
	Properties
	{
		[NoScaleOffset] _MainTexture("MainTexture", 2D) = "white" {}
		_MainUV("MainUV", Vector) = (0,0,0,0)
		_Color("Color", Color) = (1,1,1,1)
	}
		SubShader
		{
			Tags
			{
				"RenderPipeline" = "LightweightPipeline"
				"RenderType" = "Opaque"
				"Queue" = "Transparent+0"
			}
			Pass
			{
				Tags{"LightMode" = "LightweightForward"}

				// Material options generated by graph

				Blend SrcAlpha OneMinusSrcAlpha//Blend One Zero, One Zero

				Cull Back

				ZTest LEqual

				ZWrite On

				HLSLPROGRAM
			// Required to compile gles 2.0 with standard srp library
			#pragma prefer_hlslcc gles
			#pragma exclude_renderers d3d11_9x
			#pragma target 2.0

			// -------------------------------------
			// Lightweight Pipeline keywords
			#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
			#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
			#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
			#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
			#pragma multi_compile _ _SHADOWS_SOFT
			#pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE

			// -------------------------------------
			// Unity defined keywords
			#pragma multi_compile _ DIRLIGHTMAP_COMBINED
			#pragma multi_compile _ LIGHTMAP_ON
			#pragma multi_compile_fog

			//--------------------------------------
			// GPU Instancing
			#pragma multi_compile_instancing

			#pragma vertex vert
			#pragma fragment frag

			// Defines generated by graph

			#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
			#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
			#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
			#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
			#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

			CBUFFER_START(UnityPerMaterial)
			float2 _MainUV;
			CBUFFER_END

			TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
			struct VertexDescriptionInputs
			{
				float3 ObjectSpacePosition;
			};

			struct SurfaceDescriptionInputs
			{
				float3 TangentSpaceNormal;
			};


			struct VertexDescription
			{
				float3 Position;
			};

			VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
			{
				VertexDescription description = (VertexDescription)0;
				description.Position = IN.ObjectSpacePosition;
				return description;
			}

			struct SurfaceDescription
			{
				float3 Albedo;
				float3 Normal;
				float3 Emission;
				float Metallic;
				float Smoothness;
				float Occlusion;
				float Alpha;
				float AlphaClipThreshold;
			};

			float4 _Color;

			SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
			{
				SurfaceDescription surface = (SurfaceDescription)0;
				float2 _Property_8E0D1810_Out_0 = _MainUV;
				float4 _SampleTexture2D_AB14B8F7_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, _Property_8E0D1810_Out_0);
				float _SampleTexture2D_AB14B8F7_R_4 = _SampleTexture2D_AB14B8F7_RGBA_0.r;
				float _SampleTexture2D_AB14B8F7_G_5 = _SampleTexture2D_AB14B8F7_RGBA_0.g;
				float _SampleTexture2D_AB14B8F7_B_6 = _SampleTexture2D_AB14B8F7_RGBA_0.b;
				float _SampleTexture2D_AB14B8F7_A_7 = _SampleTexture2D_AB14B8F7_RGBA_0.a;
				
				surface.Albedo = _Color.xyz + (0.4f + cos(_Time.w + _MainUV.y) * 0.2f);

				surface.Normal = IN.TangentSpaceNormal;
				surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
				surface.Metallic = 0;
				surface.Smoothness = 0.5;
				surface.Occlusion = 1;

				surface.Alpha = 0.5f;

				surface.AlphaClipThreshold = 0.5;
				return surface;
			}

			struct GraphVertexInput
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
				float4 texcoord1 : TEXCOORD1;
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};


			struct GraphVertexOutput
			{
				float4 clipPos                : SV_POSITION;
				DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
				half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
				float4 shadowCoord            : TEXCOORD2;

				// Interpolators defined by graph
				float3 WorldSpacePosition : TEXCOORD3;
				float3 WorldSpaceNormal : TEXCOORD4;
				float3 WorldSpaceTangent : TEXCOORD5;
				float3 WorldSpaceBiTangent : TEXCOORD6;
				float3 WorldSpaceViewDirection : TEXCOORD7;
				half4 uv1 : TEXCOORD8;

				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};

			GraphVertexOutput vert(GraphVertexInput v)
			{
				GraphVertexOutput o = (GraphVertexOutput)0;
				UNITY_SETUP_INSTANCE_ID(v);
				UNITY_TRANSFER_INSTANCE_ID(v, o);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

				// Vertex transformations performed by graph
				float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
				float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
				float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
				float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
				float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
				float4 uv1 = v.texcoord1;
				float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

				VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

				// Vertex description inputs defined by graph
				vdi.ObjectSpacePosition = ObjectSpacePosition;

				VertexDescription vd = PopulateVertexData(vdi);
				v.vertex.xyz = vd.Position;

				// Vertex shader outputs defined by graph
				o.WorldSpacePosition = WorldSpacePosition;
				o.WorldSpaceNormal = WorldSpaceNormal;
				o.WorldSpaceTangent = WorldSpaceTangent;
				o.WorldSpaceBiTangent = WorldSpaceBiTangent;
				o.WorldSpaceViewDirection = WorldSpaceViewDirection;
				o.uv1 = uv1;

				float3 lwWNormal = TransformObjectToWorldNormal(v.normal);

				VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);

				// We either sample GI from lightmap or SH.
				// Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
				// see DECLARE_LIGHTMAP_OR_SH macro.
				// The following funcions initialize the correct variable with correct data
				OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
				OUTPUT_SH(lwWNormal, o.vertexSH);

				half3 vertexLight = VertexLighting(vertexInput.positionWS, lwWNormal);
				half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
				o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
				o.clipPos = vertexInput.positionCS;

			#ifdef _MAIN_LIGHT_SHADOWS
				o.shadowCoord = GetShadowCoord(vertexInput);
			#endif
				return o;
			}

			half4 frag(GraphVertexOutput IN) : SV_Target
			{
				UNITY_SETUP_INSTANCE_ID(IN);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

				// Pixel transformations performed by graph
				float3 WorldSpacePosition = IN.WorldSpacePosition;
				float3 WorldSpaceNormal = IN.WorldSpaceNormal;
				float3 WorldSpaceTangent = IN.WorldSpaceTangent;
				float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
				float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
				float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
				float4 uv1 = IN.uv1;
				float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

				SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

				// Surface description inputs defined by graph
				surfaceInput.TangentSpaceNormal = TangentSpaceNormal;

				SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

				float3 Albedo = float3(0.5, 0.5, 0.5);
				float3 Specular = float3(0, 0, 0);
				float Metallic = 1;
				float3 Normal = float3(0, 0, 1);
				float3 Emission = 0;
				float Smoothness = 0.5;
				float Occlusion = 1;
				float Alpha = 1;
				float AlphaClipThreshold = 0;

				// Surface description remap performed by graph
				Albedo = surf.Albedo;
				Normal = surf.Normal;
				Emission = surf.Emission;
				Metallic = surf.Metallic;
				Smoothness = surf.Smoothness;
				Occlusion = surf.Occlusion;
				Alpha = surf.Alpha;
				AlphaClipThreshold = surf.AlphaClipThreshold;

				InputData inputData;
				inputData.positionWS = WorldSpacePosition;

		#ifdef _NORMALMAP
				inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
		#else
			#if !SHADER_HINT_NICE_QUALITY
				inputData.normalWS = WorldSpaceNormal;
			#else
				inputData.normalWS = normalize(WorldSpaceNormal);
			#endif
		#endif

		#if !SHADER_HINT_NICE_QUALITY
				// viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
				inputData.viewDirectionWS = WorldSpaceViewDirection;
		#else
				inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
		#endif

				inputData.shadowCoord = IN.shadowCoord;

				inputData.fogCoord = IN.fogFactorAndVertexLight.x;
				inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
				inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

				half4 color = LightweightFragmentPBR(
					inputData,
					Albedo,
					Metallic,
					Specular,
					Smoothness,
					Occlusion,
					Emission,
					Alpha);

				// Computes fog factor per-vertex
				color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);

		#if _AlphaClip
				clip(Alpha - AlphaClipThreshold);
		#endif
				return color;
			}

			ENDHLSL
		}

		Pass
		{
			Name "DepthOnly"
			Tags{"LightMode" = "DepthOnly"}

			ZWrite On
			ColorMask 0

				// Material options generated by graph
				Cull Back

				HLSLPROGRAM
				// Required to compile gles 2.0 with standard srp library
				#pragma prefer_hlslcc gles
				#pragma exclude_renderers d3d11_9x
				#pragma target 2.0

				//--------------------------------------
				// GPU Instancing
				#pragma multi_compile_instancing

				#pragma vertex vert
				#pragma fragment frag

				// Defines generated by graph

				#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
				#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
				#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
				#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

				CBUFFER_START(UnityPerMaterial)
				float2 _MainUV;
				CBUFFER_END

				TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
				struct VertexDescriptionInputs
				{
					float3 ObjectSpacePosition;
				};

				struct SurfaceDescriptionInputs
				{
					float3 TangentSpaceNormal;
				};


				struct VertexDescription
				{
					float3 Position;
				};

				VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
				{
					VertexDescription description = (VertexDescription)0;
					description.Position = IN.ObjectSpacePosition;
					return description;
				}

				struct SurfaceDescription
				{
					float3 Albedo;
					float3 Emission;
					float Alpha;
					float AlphaClipThreshold;
				};

				SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
				{
					SurfaceDescription surface = (SurfaceDescription)0;
					float2 _Property_8E0D1810_Out_0 = _MainUV;
					float4 _SampleTexture2D_AB14B8F7_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, _Property_8E0D1810_Out_0);
					float _SampleTexture2D_AB14B8F7_R_4 = _SampleTexture2D_AB14B8F7_RGBA_0.r;
					float _SampleTexture2D_AB14B8F7_G_5 = _SampleTexture2D_AB14B8F7_RGBA_0.g;
					float _SampleTexture2D_AB14B8F7_B_6 = _SampleTexture2D_AB14B8F7_RGBA_0.b;
					float _SampleTexture2D_AB14B8F7_A_7 = _SampleTexture2D_AB14B8F7_RGBA_0.a;
					surface.Albedo = (_SampleTexture2D_AB14B8F7_RGBA_0.xyz);
					surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
					surface.Alpha = 1;
					surface.AlphaClipThreshold = 0.5;
					return surface;
				}

				struct GraphVertexInput
				{
					float4 vertex : POSITION;
					float3 normal : NORMAL;
					float4 tangent : TANGENT;
					float4 texcoord1 : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
				};


				struct VertexOutput
				{
					float2 uv           : TEXCOORD0;
					float4 clipPos      : SV_POSITION;
					// Interpolators defined by graph
					float3 WorldSpacePosition : TEXCOORD3;
					float3 WorldSpaceNormal : TEXCOORD4;
					float3 WorldSpaceTangent : TEXCOORD5;
					float3 WorldSpaceBiTangent : TEXCOORD6;
					float3 WorldSpaceViewDirection : TEXCOORD7;
					half4 uv1 : TEXCOORD8;

					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				VertexOutput vert(GraphVertexInput v)
				{
					VertexOutput o = (VertexOutput)0;
					UNITY_SETUP_INSTANCE_ID(v);
					UNITY_TRANSFER_INSTANCE_ID(v, o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

					// Vertex transformations performed by graph
					float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
					float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
					float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
					float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
					float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
					float4 uv1 = v.texcoord1;
					float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

					VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

					// Vertex description inputs defined by graph
					vdi.ObjectSpacePosition = ObjectSpacePosition;

					VertexDescription vd = PopulateVertexData(vdi);
					v.vertex.xyz = vd.Position;

					// Vertex shader outputs defined by graph
					o.WorldSpacePosition = WorldSpacePosition;
					o.WorldSpaceNormal = WorldSpaceNormal;
					o.WorldSpaceTangent = WorldSpaceTangent;
					o.WorldSpaceBiTangent = WorldSpaceBiTangent;
					o.WorldSpaceViewDirection = WorldSpaceViewDirection;
					o.uv1 = uv1;

					o.clipPos = TransformObjectToHClip(v.vertex.xyz);
					return o;
				}

				half4 frag(VertexOutput IN) : SV_TARGET
				{
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

					// Pixel transformations performed by graph
					float3 WorldSpacePosition = IN.WorldSpacePosition;
					float3 WorldSpaceNormal = IN.WorldSpaceNormal;
					float3 WorldSpaceTangent = IN.WorldSpaceTangent;
					float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
					float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
					float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
					float4 uv1 = IN.uv1;
					float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

					SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

					// Surface description inputs defined by graph
					surfaceInput.TangentSpaceNormal = TangentSpaceNormal;

					SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

					float3 Albedo = float3(0.5, 0.5, 0.5);
					float3 Emission = 0;
					float Alpha = 1;
					float AlphaClipThreshold = 0;

					// Surface description remap performed by graph
					Albedo = surf.Albedo;
					Emission = surf.Emission;
					Alpha = surf.Alpha;
					AlphaClipThreshold = surf.AlphaClipThreshold;

			 #if _AlphaClip
					clip(Alpha - AlphaClipThreshold);
			#endif
					return 0;
				}
				ENDHLSL
			}

				// This pass it not used during regular rendering, only for lightmap baking.
				Pass
				{
					Name "Meta"
					Tags{"LightMode" = "Meta"}

					Cull Off

					HLSLPROGRAM
					// Required to compile gles 2.0 with standard srp library
					#pragma prefer_hlslcc gles
					#pragma exclude_renderers d3d11_9x
					#pragma target 2.0

					#pragma vertex vert
					#pragma fragment frag

					float4 _MainTex_ST;

				// Defines generated by graph

				#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
				#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl"
				#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
				#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

				#pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

					CBUFFER_START(UnityPerMaterial)
				float2 _MainUV;
				CBUFFER_END

				TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
				struct VertexDescriptionInputs
				{
					float3 ObjectSpacePosition;
				};

				struct SurfaceDescriptionInputs
				{
					float3 TangentSpaceNormal;
				};


				struct VertexDescription
				{
					float3 Position;
				};

				VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
				{
					VertexDescription description = (VertexDescription)0;
					description.Position = IN.ObjectSpacePosition;
					return description;
				}

				struct SurfaceDescription
				{
					float3 Albedo;
					float3 Emission;
					float Alpha;
					float AlphaClipThreshold;
				};

				SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
				{
					SurfaceDescription surface = (SurfaceDescription)0;
					float2 _Property_8E0D1810_Out_0 = _MainUV;
					float4 _SampleTexture2D_AB14B8F7_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, _Property_8E0D1810_Out_0);
					float _SampleTexture2D_AB14B8F7_R_4 = _SampleTexture2D_AB14B8F7_RGBA_0.r;
					float _SampleTexture2D_AB14B8F7_G_5 = _SampleTexture2D_AB14B8F7_RGBA_0.g;
					float _SampleTexture2D_AB14B8F7_B_6 = _SampleTexture2D_AB14B8F7_RGBA_0.b;
					float _SampleTexture2D_AB14B8F7_A_7 = _SampleTexture2D_AB14B8F7_RGBA_0.a;
					surface.Albedo = (_SampleTexture2D_AB14B8F7_RGBA_0.xyz);
					surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
					surface.Alpha = 1;
					surface.AlphaClipThreshold = 0.5;
					return surface;
				}

				struct GraphVertexInput
				{
					float4 vertex : POSITION;
					float3 normal : NORMAL;
					float4 tangent : TANGENT;
					float4 texcoord1 : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
				};


				struct VertexOutput
				{
					float2 uv           : TEXCOORD0;
					float4 clipPos      : SV_POSITION;
					// Interpolators defined by graph
					float3 WorldSpacePosition : TEXCOORD3;
					float3 WorldSpaceNormal : TEXCOORD4;
					float3 WorldSpaceTangent : TEXCOORD5;
					float3 WorldSpaceBiTangent : TEXCOORD6;
					float3 WorldSpaceViewDirection : TEXCOORD7;
					half4 uv1 : TEXCOORD8;

					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				VertexOutput vert(GraphVertexInput v)
				{
					VertexOutput o = (VertexOutput)0;
					UNITY_SETUP_INSTANCE_ID(v);
					UNITY_TRANSFER_INSTANCE_ID(v, o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

					// Vertex transformations performed by graph
					float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
					float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
					float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
					float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
					float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
					float4 uv1 = v.texcoord1;
					float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;


					// Vertex shader outputs defined by graph
					o.WorldSpacePosition = WorldSpacePosition;
					o.WorldSpaceNormal = WorldSpaceNormal;
					o.WorldSpaceTangent = WorldSpaceTangent;
					o.WorldSpaceBiTangent = WorldSpaceBiTangent;
					o.WorldSpaceViewDirection = WorldSpaceViewDirection;
					o.uv1 = uv1;

					o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST, unity_DynamicLightmapST);
					return o;
				}

				half4 frag(VertexOutput IN) : SV_TARGET
				{
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

					// Pixel transformations performed by graph
					float3 WorldSpacePosition = IN.WorldSpacePosition;
					float3 WorldSpaceNormal = IN.WorldSpaceNormal;
					float3 WorldSpaceTangent = IN.WorldSpaceTangent;
					float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
					float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
					float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
					float4 uv1 = IN.uv1;
					float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

					SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

					// Surface description inputs defined by graph
					surfaceInput.TangentSpaceNormal = TangentSpaceNormal;

					SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

					float3 Albedo = float3(0.5, 0.5, 0.5);
					float3 Emission = 0;
					float Alpha = 1;
					float AlphaClipThreshold = 0;

					// Surface description remap performed by graph
					Albedo = surf.Albedo;
					Emission = surf.Emission;
					Alpha = surf.Alpha;
					AlphaClipThreshold = surf.AlphaClipThreshold;

			 #if _AlphaClip
					clip(Alpha - AlphaClipThreshold);
			#endif

					MetaInput metaInput = (MetaInput)0;
					metaInput.Albedo = Albedo;
					metaInput.Emission = Emission;

					return MetaFragment(metaInput);
				}
				ENDHLSL
			}
			Pass
			{
				Tags{"LightMode" = "Lightweight2D"}

				// Material options generated by graph

				Blend One Zero, One Zero

				Cull Back

				ZTest LEqual

				ZWrite On

				HLSLPROGRAM
					// Required to compile gles 2.0 with standard srp library
					#pragma enable_d3d11_debug_symbols
					#pragma prefer_hlslcc gles
					#pragma exclude_renderers d3d11_9x
					#pragma target 2.0

					#pragma vertex vert
					#pragma fragment frag

					// Defines generated by graph

					#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
					#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
					#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
					#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
					#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

					CBUFFER_START(UnityPerMaterial)
					float2 _MainUV;
					CBUFFER_END

					TEXTURE2D(_MainTexture); SAMPLER(sampler_MainTexture); float4 _MainTexture_TexelSize;
					struct VertexDescriptionInputs
					{
						float3 ObjectSpacePosition;
					};

					struct SurfaceDescriptionInputs
					{
						float3 TangentSpaceNormal;
					};


					struct VertexDescription
					{
						float3 Position;
					};

					VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
					{
						VertexDescription description = (VertexDescription)0;
						description.Position = IN.ObjectSpacePosition;
						return description;
					}

					struct SurfaceDescription
					{
						float3 Albedo;
						float3 Normal;
						float3 Emission;
						float Metallic;
						float Smoothness;
						float Occlusion;
						float Alpha;
						float AlphaClipThreshold;
					};

					SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
					{
						SurfaceDescription surface = (SurfaceDescription)0;
						float2 _Property_8E0D1810_Out_0 = _MainUV;
						float4 _SampleTexture2D_AB14B8F7_RGBA_0 = SAMPLE_TEXTURE2D(_MainTexture, sampler_MainTexture, _Property_8E0D1810_Out_0);
						float _SampleTexture2D_AB14B8F7_R_4 = _SampleTexture2D_AB14B8F7_RGBA_0.r;
						float _SampleTexture2D_AB14B8F7_G_5 = _SampleTexture2D_AB14B8F7_RGBA_0.g;
						float _SampleTexture2D_AB14B8F7_B_6 = _SampleTexture2D_AB14B8F7_RGBA_0.b;
						float _SampleTexture2D_AB14B8F7_A_7 = _SampleTexture2D_AB14B8F7_RGBA_0.a;
						surface.Albedo = (_SampleTexture2D_AB14B8F7_RGBA_0.xyz);
						surface.Normal = IN.TangentSpaceNormal;
						surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
						surface.Metallic = 0;
						surface.Smoothness = 0.5;
						surface.Occlusion = 1;
						surface.Alpha = 1;
						surface.AlphaClipThreshold = 0.5;
						return surface;
					}

					struct GraphVertexInput
					{
						float4 vertex : POSITION;
						float3 normal : NORMAL;
						float4 tangent : TANGENT;
						float4 texcoord1 : TEXCOORD1;
						UNITY_VERTEX_INPUT_INSTANCE_ID
					};


					struct GraphVertexOutput
					{
						float4 clipPos                : SV_POSITION;
						// Interpolators defined by graph
						float3 WorldSpacePosition : TEXCOORD3;
						float3 WorldSpaceNormal : TEXCOORD4;
						float3 WorldSpaceTangent : TEXCOORD5;
						float3 WorldSpaceBiTangent : TEXCOORD6;
						float3 WorldSpaceViewDirection : TEXCOORD7;
						half4 uv1 : TEXCOORD8;

						UNITY_VERTEX_OUTPUT_STEREO
					};

					GraphVertexOutput vert(GraphVertexInput v)
					{
						GraphVertexOutput o = (GraphVertexOutput)0;
						UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

						// Vertex transformations performed by graph
						float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
						float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
						float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
						float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
						float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
						float4 uv1 = v.texcoord1;
						float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

						VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

						// Vertex description inputs defined by graph
						vdi.ObjectSpacePosition = ObjectSpacePosition;

						VertexDescription vd = PopulateVertexData(vdi);
						v.vertex.xyz = vd.Position;

						// Vertex shader outputs defined by graph
						o.WorldSpacePosition = WorldSpacePosition;
						o.WorldSpaceNormal = WorldSpaceNormal;
						o.WorldSpaceTangent = WorldSpaceTangent;
						o.WorldSpaceBiTangent = WorldSpaceBiTangent;
						o.WorldSpaceViewDirection = WorldSpaceViewDirection;
						o.uv1 = uv1;


						VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
						o.clipPos = vertexInput.positionCS;

						return o;
					}

					half4 frag(GraphVertexOutput IN) : SV_Target
					{
						UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

					// Pixel transformations performed by graph
					float3 WorldSpacePosition = IN.WorldSpacePosition;
					float3 WorldSpaceNormal = IN.WorldSpaceNormal;
					float3 WorldSpaceTangent = IN.WorldSpaceTangent;
					float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
					float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
					float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
					float4 uv1 = IN.uv1;
					float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

					SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

					// Surface description inputs defined by graph
					surfaceInput.TangentSpaceNormal = TangentSpaceNormal;

					SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

					float3 Albedo = float3(0.5, 0.5, 0.5);
					float3 Specular = float3(0, 0, 0);
					float Metallic = 1;
					float3 Normal = float3(0, 0, 1);
					float3 Emission = 0;
					float Smoothness = 0.5;
					float Occlusion = 1;
					float Alpha = 1;
					float AlphaClipThreshold = 0;

					// Surface description remap performed by graph
					Albedo = surf.Albedo;
					Normal = surf.Normal;
					Emission = surf.Emission;
					Metallic = surf.Metallic;
					Smoothness = surf.Smoothness;
					Occlusion = surf.Occlusion;
					Alpha = surf.Alpha;
					AlphaClipThreshold = surf.AlphaClipThreshold;


					// Computes fog factor per-vertex
					half4 color = half4(Albedo, Alpha);

			#if _AlphaClip
					clip(Alpha - AlphaClipThreshold);
			#endif
					return color;
				}

				ENDHLSL
			}
		}
			CustomEditor "UnityEditor.ShaderGraph.PBRMasterGUI"
					FallBack "Hidden/InternalErrorShader"
}
